<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Chat del Hotel</title>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-storage-compat.js"></script>

  <!-- UI libs -->
  <script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/lucide@0.292.0/dist/umd/lucide.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">

  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Manrope','system-ui','-apple-system','Segoe UI','Roboto','sans-serif'] },
          boxShadow: { soft: '0 6px 22px rgba(0,0,0,.08)' }
        }
      }
    }
  </script>
  <script src="translations.js?v=54" defer></script>

  <style>
:root {
  --chat-primary:#111111;
  --assistant-text:#000000; /* üÜï color del texto del asistente */
  --chat-client-text:#ffffff;
  --chat-header-text:#1f2937;
  --avatar-radius:50%;
}
    html,body { height:100%; background:#ececec; }
    body { font-family: Manrope, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; -webkit-tap-highlight-color: transparent; }
    /* Contenedor principal del chat (ocupando todo el iframe/p√°gina) */
    #chatWindow {
      position: fixed; inset: 0; background:#ececec;
      display:flex; flex-direction:column; z-index: 9999;
      height: 100dvh; opacity:1; transform:none;
    }
    /* Header fijo */
    #chatHeader { position: sticky; top:0; z-index:10; }
    /* Scroll mensajes */
    #chatBox { flex:1; overflow-y:auto; -webkit-overflow-scrolling:touch; padding:12px 16px 16px; }
    /* Footer input fijo */
    #chatFooter { position: sticky; bottom:0; z-index:10;padding:12px 16px calc(12px + env(safe-area-inset-bottom)); }
    /* Initial menu fijo sobre el input */
    #initialMenu {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
    }
    /* Burbujas */
    .chat-bubble { max-width: 86%; font-size:15px; line-height:1.45; }
    .chat-assistant { display:flex; align-items:flex-start; gap:10px; background:transparent; }
.chat-assistant .msg {
  background:#fff;
  border-radius:14px;
  padding:10px 14px;
  box-shadow:0 1px 3px rgba(0,0,0,.08);
  color: var(--assistant-text);
}
    .chat-assistant .msg { overflow: visible !important; }
    .chat-assistant .msg iframe {
      display:block;
      width:100%;
      height:215px !important;
    }
    .chat-user { margin-left:auto; color:var(--chat-client-text, #fff); background:var(--chat-primary); border-radius:14px; padding:10px 14px; }
    /* Enlaces dentro de mensajes */
    .chat-bubble a:not(.pill-btn) { color:#0a66ff; text-decoration:underline; }
    .chat-bubble a:not(.pill-btn):hover { text-decoration:none; }
    /* Bot√≥n enviar */
    #sendChatBtn { flex-shrink:0; width:40px; height:40px; border-radius:9999px; display:flex; align-items:center; justify-content:center; background:#000; color:#fff; }
    /* Color din√°mico aplicado tambi√©n al nombre del hotel */
    #chatHeader { color: var(--chat-header-text, #1f2937); }
    #chatHotelName { color: var(--chat-header-text, var(--chat-primary)) !important; }
    #chatMenuBtn,
    #chatHeader button { color: var(--chat-header-text, #1f2937) !important; }
    #chatHeader button svg,
    #chatHeader svg { color: inherit !important; stroke: currentColor !important; }
    /* Avatar asistente dentro de mensaje */
    .avatar-icon { width:36px; height:36px; border-radius:var(--avatar-radius, 50%); object-fit:cover; margin-top:2px; flex-shrink:0; box-shadow:0 1px 3px rgba(0,0,0,.1); }
    /* Cards (autoResponses tipo cards) */
.cards {
  display: flex;
  flex-wrap: nowrap;
  gap: 12px;
  overflow-x: auto;
  overflow-y: hidden;
  padding: 2px 4px 10px;
  -webkit-overflow-scrolling: touch;
  scroll-snap-type: x mandatory;

  /* üî• ESTO ES LO QUE HACE QUE FUNCIONE */
  overscroll-behavior: contain; /* evita mover el #chatBox */
  touch-action: pan-x;           /* bloquea el scroll vertical mientras arrastras horizontal */
}

    .card {
      flex:0 0 260px; background:#fff; border-radius:14px; box-shadow:0 1px 3px rgba(0,0,0,.08);
      scroll-snap-align:start;
      border:1px solid #eaeaea; overflow:hidden;
    }
    .card img { width:100%; height:140px; object-fit:cover; display:block; }
    .card .in { padding:10px 12px; }
    .card .title { font-weight:700; font-size:15px; }
    .card .sub { font-size:13px; color:#555; margin-top:2px; }
    .pill-btn {
      display:inline-block; margin-top:8px; border:1.5px solid var(--chat-primary);
      color:var(--chat-primary); border-radius:9999px; padding:6px 10px; font-size:12px;
    }
    .pill-btn:hover { background:var(--chat-primary); color:#fff; }
    #initialMenu .pill-btn { margin-top: 0; }
    .chat-bubble .pill-btn {
      color:inherit;
      border-color:currentColor;
      text-decoration:none;
    }
    .chat-bubble .pill-btn:hover {
      background:var(--chat-primary);
      border-color:var(--chat-primary);
      color:#fff;
      text-decoration:none;
    }
    /* Input */
    #chatInput {
      flex:1; background:#fff; border:1px solid #ddd; border-radius:10px; padding:10px 14px; font-size:16px;
      outline:none; box-shadow:0 0 4px 1px #02243114; transition: box-shadow .2s;
    }
    #chatInput:focus { box-shadow:0 0 6px 1px #02243126; }

    input::placeholder {
      color: #6b7280 !important; /* gray-500 */
      opacity: 0.9;
    }

    .dot {
  width: 6px;
  height: 6px;
  background-color: #888; /* puedes cambiar el color */
  border-radius: 50%;
  display: inline-block;
  animation: blink 1.2s infinite;
}

.dot:nth-child(2) { animation-delay: 0.2s; }
.dot:nth-child(3) { animation-delay: 0.4s; }

@keyframes blink {
  0%, 80%, 100% { opacity: 0.3; }
  40% { opacity: 1; }
}

@keyframes slideInLead {
  0% { opacity: 0; transform: translateY(25px); }
  100% { opacity: 1; transform: translateY(0); }
}

/* Comportamiento natural y suave tipo Delphi.ai */
@media (min-width: 768px) {

  /* Mensajes */
  #chatBox {
    width: 100%;
    max-width: 880px;
    margin: 0 auto;
    padding-left: 24px;
    padding-right: 24px;
  }

  /* Input */
  #chatFooter {
    width: 100%;
    max-width: 880px;
    margin: 0 auto;
    padding-left: 24px;
    padding-right: 24px;
  }
}


  </style>
</head>
<body>
  <div id="pwdScreen" class="fixed inset-0 bg-white flex flex-col items-center justify-center gap-4 text-center z-[999999]">
    <h2 id="pwdTitle" class="text-lg font-semibold">Enter Password</h2>
    <input id="pwdInput" type="password" class="border border-gray-300 rounded-lg px-3 py-2 w-64" />
    <button id="pwdBtn" class="px-4 py-2 bg-black text-white rounded-lg">Enter</button>
    <p id="pwdError" class="text-red-500 text-sm hidden">Wrong password</p>
  </div>
  <!-- VISTA DEL CHAT (siempre visible, sin hero ni men√∫s) -->
  <div id="chatWindow">
    <!-- Header -->
    <div id="chatHeader" class="bg-white flex items-center justify-between px-4 py-4">
      <div class="flex items-center gap-3">
        <img id="chatLogo" class="w-9 h-9 rounded-full shadow hidden" alt="Logo">
        <span id="chatHotelName" class="font-semibold text-[17px] text-gray-800">Tomos Bot</span>
      </div>
      <div class="flex items-center gap-4">
        <div class="relative">
          <button id="chatMenuBtn" type="button" class="text-gray-500 select-none cursor-pointer flex items-center justify-center w-8 h-8 rounded-full hover:bg-gray-100" title="Men√∫" aria-haspopup="true" aria-expanded="false">‚Ä¢‚Ä¢‚Ä¢</button>
          <div id="chatMenu" class="hidden absolute right-0 mt-2 w-56 bg-white rounded-lg shadow-lg border border-gray-100 py-1 text-sm z-20">
            <button id="downloadChatBtn" type="button" class="w-full px-3 py-2 text-left text-gray-700 hover:bg-gray-100 flex items-center gap-2">
              <i data-lucide="download" class="w-4 h-4"></i>
              <span>Download conversation</span>
            </button>
          </div>
        </div>
        <button id="closeChat" class="text-gray-400 hover:text-gray-600" title="Cerrar">
          <i data-lucide="x" class="w-5 h-5"></i>
        </button>
      </div>
    </div>

    <!-- Mensajes -->
    <div id="chatBox" class="flex flex-col gap-3"></div>

    <!-- Footer -->
    <div id="chatFooter" class="flex flex-col gap-3">
      <div id="initialMenu" class="hidden" aria-label="Initial menu"></div>
      <div class="flex items-center gap-3">
        <input id="chatInput" type="text" placeholder="√âcrivez votre message‚Ä¶" />
        <button id="sendChatBtn"><i data-lucide="arrow-up" class="w-5 h-5"></i></button>
      </div>
    </div>

<div class="flex justify-center items-center py-2">
  <a href="https://tomos.io" target="_blank" rel="noopener noreferrer" 
     class="flex items-center gap-2 text-gray-500 text-xs">
    <span>Powered by Tomos</span>
  </a>
</div>


  </div>

  <script>
    let USER_LANGUAGE = 'en';
    document.addEventListener('DOMContentLoaded', () => {
      if (window.translationManager) {
        translationManager.init();
      }

      const BROWSER_LANGUAGE = (navigator.language || navigator.userLanguage || 'en').slice(0, 2).toLowerCase();
      const activeLanguage = window.translationManager
        ? translationManager.getCurrentLanguage()
        : BROWSER_LANGUAGE;
      const TEXT_TRANSLATIONS = {
        es: {
          inputPlaceholder: 'Escribe tu mensaje‚Ä¶',
          downloadConversation: 'Descargar conversaci√≥n'
        },
        en: {
          inputPlaceholder: 'Write your message‚Ä¶',
          downloadConversation: 'Download conversation'
        },
        fr: {
          inputPlaceholder: '√âcrivez votre message‚Ä¶',
          downloadConversation: 'T√©l√©charger la conversation'
        },
        de: {
          inputPlaceholder: 'Schreibe deine Nachricht‚Ä¶',
          downloadConversation: 'Unterhaltung herunterladen'
        },
        pt: {
          inputPlaceholder: 'Escreva sua mensagem‚Ä¶',
          downloadConversation: 'Baixar conversa'
        }
      };

      const selected = TEXT_TRANSLATIONS[activeLanguage] || TEXT_TRANSLATIONS.en;

      const chatInput = document.getElementById('chatInput');
      if (chatInput) {
        chatInput.placeholder = selected.inputPlaceholder;
      }

      USER_LANGUAGE = activeLanguage;

      const downloadChatBtnLabel = document.querySelector('#downloadChatBtn span');
      if (downloadChatBtnLabel) {
        downloadChatBtnLabel.textContent = selected.downloadConversation;
      }

      if (window.translationManager) {
        translationManager.register(document.getElementById('pwdTitle'), 'Enter Password');
        translationManager.register(document.getElementById('pwdBtn'), 'Enter');
        translationManager.register(document.getElementById('pwdError'), 'Wrong password');
      }
    });
  </script>

  <script>
/* =========================
   FIREBASE CONFIG
========================= */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyC2c3S_NtouIjHPrk5LM5c0DQoTWyBrzH4",
  authDomain: "timbre-c9547.firebaseapp.com",
  databaseURL: "https://timbre-c9547-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "timbre-c9547",
  storageBucket: "timbre-c9547.firebasestorage.app",
  messagingSenderId: "127064655657",
  appId: "1:127064655657:web:a4e99dcbc6ab33f32c1938"
};

let app;
let db;

try {
  app = firebase.app(); // reuse existing app if already initialized
} catch (e) {
  app = firebase.initializeApp(FIREBASE_CONFIG);
}
db = firebase.database(app);

function dbRef(path) {
  return db.ref(path);
}

function getEmpresa(){
  const url = new URL(window.location.href);
  const p = (url.searchParams.get('empresa') || localStorage.getItem('empresa') || 'Boletum').trim();
  localStorage.setItem('empresa', p);
  return p;
}
let EMPRESA = getEmpresa();

function getBot() {
  const url = new URL(window.location.href);
  const storageKey = `bot:${EMPRESA}`;
  const raw = (url.searchParams.get('bot') || localStorage.getItem(storageKey) || 'default').trim();
  const bot = raw || 'default';
  localStorage.setItem(storageKey, bot);
  return bot;
}
let BOT = getBot();

const CHAT_SESSION_KEY = `chatId:${EMPRESA}:${BOT}`;
let CHAT_ID = sessionStorage.getItem(CHAT_SESSION_KEY) || `${Date.now()}`;
sessionStorage.setItem(CHAT_SESSION_KEY, CHAT_ID);

const chatLogBaseRef = dbRef(`empresas/${EMPRESA}/bots/${BOT}/conversaciones/${CHAT_ID}`);
const chatMessagesRef = chatLogBaseRef.child('messages');
const chatMetaRef = chatLogBaseRef.child('meta');
let chatMetaCache = null;
let chatStartedAt = null;
const conversationLog = []; // {sender:'bot'|'user', text:string, time:number}
const pendingMessagesQueue = [];
let hasUserSentMessage = false;
let externalOriginRequested = false;
let externalOriginSaved = false;
let externalOriginFallbackTimeout = null;

async function fetchUserLocation() {
  try {
    const response = await fetch('https://ipapi.co/json/');
    if (!response.ok) throw new Error('Failed to fetch location');
    const data = await response.json();
    return {
      ip: data?.ip || '',
      country: data?.country_name || '',
      city: data?.city || '',
      region: data?.region || data?.region_name || '',
      countryCode: data?.country || ''
    };
  } catch (err) {
    console.warn('No se pudo obtener la ubicaci√≥n del usuario', err);
    return null;
  }
}

function flagFromCountryCode(code = '') {
  const clean = code.trim().toUpperCase();
  if (clean.length !== 2) return '';
  const BASE = 0x1F1E6 - 'A'.charCodeAt(0);
  return String.fromCodePoint(
    ...clean.split('').map((char) => char.charCodeAt(0) + BASE)
  );
}

async function saveUserLocationToFirebase() {
  if (!chatMetaRef) return;
  try {
    const location = await fetchUserLocation();
    if (!location) return;
    const payload = {
      ...location,
      flag: flagFromCountryCode(location.countryCode)
    };
    await chatMetaRef.child('location').set(payload);
  } catch (err) {
    console.warn('No se pudo guardar la ubicaci√≥n del usuario', err);
  }
}

function normalizeExternalOrigin(value) {
  if (value == null) return '';
  const str = String(value).trim();
  if (!str) return '';
  try {
    const url = new URL(str);
    return url.origin || url.hostname || str;
  } catch (err) {
    const withoutProtocol = str.replace(/^[a-zA-Z]+:\/\//, '').replace(/\/.*$/, '');
    return withoutProtocol || str;
  }
}

async function saveExternalOriginToFirebase(value) {
  if (!chatMetaRef || externalOriginSaved || chatMetaCache?.origin) return;
  const normalized = normalizeExternalOrigin(value) || '‚Äî';
  try {
    await chatMetaRef.child('origin').set(normalized);
    externalOriginSaved = true;
    chatMetaCache = { ...(chatMetaCache || {}), origin: normalized };
  } catch (err) {
    console.warn('No se pudo guardar el origen externo', err);
  }
}

function requestExternalOriginFromParent() {
  if (externalOriginRequested || externalOriginSaved || chatMetaCache?.origin) return;
  externalOriginRequested = true;
  try {
    window.parent.postMessage({ action: 'requestExternalOrigin' }, '*');
  } catch (err) {
    console.warn('No se pudo solicitar el origen externo', err);
  }

  if (externalOriginFallbackTimeout) clearTimeout(externalOriginFallbackTimeout);
  externalOriginFallbackTimeout = setTimeout(() => {
    if (!externalOriginSaved && !chatMetaCache?.origin) {
      saveExternalOriginToFirebase('‚Äî');
    }
  }, 4000);
}

const translateText = (key, vars) => {
  if (window.translationManager && typeof translationManager.translate === 'function') {
    return translationManager.translate(key, vars);
  }
  return key;
};

let leadPromptShown = false;
let leadCaptureState = null;
let leadCaptureCompleted = false;
let leadCaptureEnabled = true;
let autoOpenChatEnabled = false;
let leadCapturePopupEl = null;
let userMessageCount = 0;

let SYSTEM_PROMPT = "";
let systemPromptRef = null;

chatMetaRef.once('value').then(snapshot => {
  chatMetaCache = snapshot.val() || {};
  if (chatMetaCache.startedAt) {
    chatStartedAt = chatMetaCache.startedAt;
  }
  if (chatMetaCache.origin) {
    externalOriginSaved = true;
  }
}).catch(err => console.warn('No se pudo cargar la metadata del chat', err));

function getChatUserName() {
  const candidates = [
    `chatUserName:${EMPRESA}:${BOT}`,
    'chatUserName',
    'userName',
    'guestName',
    'name'
  ];
  for (const key of candidates) {
    const fromSession = sessionStorage.getItem(key);
    if (fromSession && fromSession.trim()) return fromSession.trim();
    const fromLocal = localStorage.getItem(key);
    if (fromLocal && fromLocal.trim()) return fromLocal.trim();
  }
  return 'Guest';
}

function stripHtml(html) {
  const tmp = document.createElement('div');
  tmp.innerHTML = html || '';
  return tmp.textContent || tmp.innerText || '';
}

function updateChatMeta(lastMessage, timestamp) {
  if (!chatMetaRef) return;
  const updates = {
    userName: getChatUserName(),
    lastMessage: lastMessage || '',
    lastUpdated: timestamp
  };
  if (!chatStartedAt) {
    chatStartedAt = chatMetaCache?.startedAt || timestamp;
  }
  if (!chatMetaCache?.startedAt) {
    updates.startedAt = chatStartedAt;
  }
  chatMetaRef.update(updates).then(() => {
    chatMetaCache = { ...(chatMetaCache || {}), ...updates };
  }).catch(err => console.warn('No se pudo actualizar la metadata del chat', err));
}

function persistChatPayload(payload) {
  if (!chatMessagesRef || !payload) return;
  try {
    const newRef = chatMessagesRef.push();
    newRef.set(payload).catch(err => console.warn('No se pudo guardar el mensaje del chat', err));
  } catch (err) {
    console.warn('No se pudo registrar la referencia del mensaje', err);
  }
  updateChatMeta(payload.text, payload.time);
}

function flushPendingMessages() {
  if (!pendingMessagesQueue.length) return;
  while (pendingMessagesQueue.length) {
    const pending = pendingMessagesQueue.shift();
    persistChatPayload(pending);
  }
}

function logChatMessage(sender, text) {
  if (!chatMessagesRef || !sender) return;
  const now = Date.now();
  const safeText = text == null ? '' : String(text);
  const payload = {
    sender,
    text: safeText,
    time: now
  };
  conversationLog.push({ sender, text: safeText, time: now });
  const isUserMessage = sender === 'user' && safeText.trim().length > 0;
  if (!hasUserSentMessage) {
    if (isUserMessage) {
      hasUserSentMessage = true;
      requestExternalOriginFromParent();
      saveUserLocationToFirebase();
      flushPendingMessages();
      persistChatPayload(payload);
    } else {
      pendingMessagesQueue.push(payload);
    }
    return;
  }
  persistChatPayload(payload);
}

function initSystemPromptListener() {
  if (systemPromptRef) {
    try {
      systemPromptRef.off();
    } catch (err) {
      console.warn('No se pudo desuscribir del prompt anterior', err);
    }
    systemPromptRef = null;
  }

  if (!EMPRESA || !BOT) {
    SYSTEM_PROMPT = "";
    return;
  }

  systemPromptRef = db.ref(`empresas/${EMPRESA}/bots/${BOT}/config/prompt`);
  systemPromptRef.on('value', (snap) => {
    const value = snap.val();
    SYSTEM_PROMPT = typeof value === 'string' ? value : '';
  }, (err) => {
    console.warn('No se pudo cargar el prompt del sistema', err);
    SYSTEM_PROMPT = '';
  });
}

let useLegacyBotPath = false;
let botCollectionPath = null;

function getDefaultBotCollectionPath() {
  return `empresas/${EMPRESA}/bots`;
}

function getConfigBotCollectionPath() {
  return `empresas/${EMPRESA}/config/bots`;
}

function getLegacyBotCollectionPath() {
  return `${EMPRESA}/bots`;
}

function getBotBasePath() {
  if (botCollectionPath) {
    const basePath = botCollectionPath.startsWith('empresas/')
      ? botCollectionPath
      : `empresas/${botCollectionPath}`;
    return `${basePath}/${BOT}`;
  }
  return useLegacyBotPath ? `empresas/${EMPRESA}` : `empresas/${EMPRESA}/bots/${BOT}`;
}

function eref(path){ return db.ref(`${getBotBasePath()}/${path}`); }

let REQUIRED_PWD = "";

eref("config/chatPassword").once("value").then(snap => {
  REQUIRED_PWD = snap.val() || "";
  
  const saved = sessionStorage.getItem(`chatPwd:${EMPRESA}:${BOT}`);

  if (!REQUIRED_PWD) {
    document.getElementById("pwdScreen").remove();
    return;
  }

  if (saved === REQUIRED_PWD) {
    document.getElementById("pwdScreen").remove();
    return;
  }
});

document.getElementById("pwdBtn").addEventListener("click", () => {
  const value = document.getElementById("pwdInput").value.trim();
  
  if (value === REQUIRED_PWD) {
    sessionStorage.setItem(`chatPwd:${EMPRESA}:${BOT}`, value);
    document.getElementById("pwdScreen").remove();
  } else {
    document.getElementById("pwdError").classList.remove("hidden");
  }
});

function applyLeadCaptureConfig(value) {
  const normalized = value === false ? false : true;
  leadCaptureEnabled = normalized;
  if (!normalized) {
    leadPromptShown = false;
    leadCaptureState = null;
    leadCaptureCompleted = false;
    hideLeadCapturePopup();
  }
}

function sendAutoOpenStatus(enabled) {
  try {
    window.parent.postMessage({ action: 'autoOpenChat', enabled: !!enabled }, '*');
  } catch (err) {
    console.warn('No se pudo notificar el estado de auto apertura del chat', err);
  }
}

function applyAutoOpenConfig(value) {
  autoOpenChatEnabled = value === true;
  sendAutoOpenStatus(autoOpenChatEnabled);
}

try {
  eref('config/leadCaptureEnabled').on('value', (snap) => {
    applyLeadCaptureConfig(snap.val());
  }, (err) => {
    console.warn('No se pudo leer config/leadCaptureEnabled', err);
  });
} catch (err) {
  console.warn('No se pudo inicializar el listener de lead capture', err);
}

try {
  eref('config/autoOpenChat').on('value', (snap) => {
    applyAutoOpenConfig(snap.val());
  }, (err) => {
    console.warn('No se pudo leer config/autoOpenChat', err);
  });
} catch (err) {
  console.warn('No se pudo inicializar el listener de auto apertura de chat', err);
}

async function prepareBotPath() {
  const candidates = [
    getDefaultBotCollectionPath(),
    getConfigBotCollectionPath(),
    getLegacyBotCollectionPath()
  ];

  for (const path of candidates) {
    try {
      await db.ref(`${path}/${BOT}`).once('value');
      botCollectionPath = path;
      useLegacyBotPath = false;
      return;
    } catch (err) {
      if (err?.code === 'PERMISSION_DENIED') {
        continue;
      }
      console.warn('No se pudo verificar la ruta del bot', path, err);
    }
  }

  try {
    const legacySnap = await db.ref(`empresas/${EMPRESA}`).once('value');
    if (legacySnap.exists()) {
      botCollectionPath = null;
      useLegacyBotPath = true;
      return;
    }
  } catch (err) {
    console.warn('No se pudo verificar la ruta legacy del bot', err);
  }

  botCollectionPath = getConfigBotCollectionPath();
  useLegacyBotPath = false;
}

/* =========================
   IA PROXY
   - Cambia PROXY_URL a tu endpoint (Vercel, etc.)
   - Tambi√©n puedes pasar ?proxy=https://tu-endpoint
========================= */
const urlParams = new URLSearchParams(location.search);
let PROXY_URL = urlParams.get('proxy') || "https://hotel-chat-proxy.vercel.app/api/chat";
// Espera respuesta JSON: { choices: [ { message: { content: "‚Ä¶" } } ] } (OpenAI-style)

/* =========================
   UI ELEMENTS
========================= */
const chatBox = document.getElementById('chatBox');
const input   = document.getElementById('chatInput');
const sendBtn = document.getElementById('sendChatBtn');
const hotelNameEl = document.getElementById('chatHotelName');
const chatLogo = document.getElementById('chatLogo');
const chatAvatarHead = document.getElementById('chatAvatarHead');
const chatMenuBtn = document.getElementById('chatMenuBtn');
const chatMenu = document.getElementById('chatMenu');
const downloadChatBtn = document.getElementById('downloadChatBtn');
const initialMenuContainer = document.getElementById('initialMenu');

function linkify(text){
  if (!text) return "";
  const urlRegex=/((https?:\/\/|www\.)[^\s]+|[a-zA-Z0-9-]+\.[a-z]{2,}(\/\S*)?)/gi;
  return text.replace(urlRegex, m=>{
    let u=m; if(!/^https?:\/\//i.test(u)) u="https://"+u;
    return `<a href="${u}" target="_blank" rel="noopener noreferrer">${m}</a>`;
  });
}
function escapeHtml(text = "") {
  return String(text)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

/* =========================
   RENDER MENSAJES
========================= */
function createAssistantBubble(avatarUrl) {
  const wrap = document.createElement('div');
  wrap.className = 'chat-bubble chat-assistant';
  const avatar = document.createElement('img');
  avatar.className = 'avatar-icon';
  if (avatarUrl) {
    avatar.src = avatarUrl;
  } else {
    avatar.style.display = 'none';
  }
  const msg = document.createElement('div');
  msg.className = 'msg';
  const assistantColor = getComputedStyle(document.documentElement)
    .getPropertyValue('--assistant-text') || '#000000';
  msg.style.color = assistantColor;
  wrap.appendChild(avatar);
  wrap.appendChild(msg);
  chatBox.appendChild(wrap);
  chatBox.scrollTop = chatBox.scrollHeight;
  return { wrap, msg };
}

function addAssistantMessageHTML(html, {avatarUrl, rawText}={}){
  const { msg } = createAssistantBubble(avatarUrl);
  msg.innerHTML = html;
  // üî• Force correct sizing of embedded iframes (YouTube, Vimeo, etc.)
  msg.querySelectorAll("iframe").forEach((ifr) => {
    ifr.style.width = "100%";
    ifr.style.height = "215px";
    ifr.style.display = "block";
    ifr.removeAttribute("width");
    ifr.removeAttribute("height");
  });

  // Evita que el scroll sobre tarjetas autom√°ticas mueva el resto del chat
  msg.querySelectorAll('.cards').forEach(cardsEl => {
    if (cardsEl.dataset.lockedScroll) return;
    const onWheel = (event) => {
      const delta = event.deltaY !== 0 ? event.deltaY : event.deltaX;
      if (delta === 0) return;
      cardsEl.scrollLeft += delta;
      event.preventDefault();
      event.stopPropagation();
    };
    cardsEl.addEventListener('wheel', onWheel, { passive: false });
    cardsEl.dataset.lockedScroll = '1';
  });

  const plain = rawText != null ? rawText : stripHtml(html);
  logChatMessage('bot', plain);
}

function addAssistantMessage(text, opts={}){
  const { avatarUrl, animate = true } = opts;
  const content = text || "";
  if (!animate) {
    const md = marked.parse(content);
    addAssistantMessageHTML(md, { avatarUrl, rawText: content });
    return;
  }

  const { msg } = createAssistantBubble(avatarUrl);
  if (!content) {
    logChatMessage('bot', '');
    return;
  }

  let index = 0;
  const total = content.length;
  const baseDelay = 18;
  const minChunk = 1;
  const chunkSize = Math.max(minChunk, Math.ceil(total / 120));

  function typeNextChunk() {
    index = Math.min(total, index + chunkSize);
    const partial = content.slice(0, index);
    msg.innerHTML = marked.parse(partial);
    chatBox.scrollTop = chatBox.scrollHeight;
    if (index < total) {
      setTimeout(typeNextChunk, baseDelay);
    } else {
      logChatMessage('bot', content);
    }
  }

  typeNextChunk();
}
function addUserMessage(text){
  const bubble = document.createElement('div');
  bubble.className = 'chat-bubble chat-user';
  bubble.textContent = text;
  chatBox.appendChild(bubble);
  chatBox.scrollTop = chatBox.scrollHeight;
  logChatMessage('user', text);
}
function addTyping(){
  const el = document.createElement('div');
  el.className = 'chat-bubble chat-assistant';
  el.dataset.typing = '1';
  el.innerHTML = `
    <img class="avatar-icon" id="__typAva" />
    <div class="msg flex items-center gap-1">
      <span class="dot"></span>
      <span class="dot"></span>
      <span class="dot"></span>
    </div>
  `;
  chatBox.appendChild(el);
  chatBox.scrollTop = chatBox.scrollHeight;
  return el;
}

function removeTyping(el){ if(el && el.parentNode) el.parentNode.removeChild(el); }

function showTypingIndicator({ avatarUrl } = {}) {
  const typing = addTyping();
  const avatarImg = typing.querySelector('#__typAva');
  const avatar = avatarUrl || CURRENT.avatarUrl;
  if (avatarImg) {
    if (avatar) {
      avatarImg.src = avatar;
    } else {
      avatarImg.style.display = 'none';
    }
  }
  return typing;
}

function delayedAssistantAction(action, delayMs = 1800, opts = {}) {
  const typing = showTypingIndicator(opts);
  setTimeout(() => {
    removeTyping(typing);
    action();
  }, delayMs);
}

function renderAssistantMessage(text) {
  addAssistantMessage(text, { avatarUrl: CURRENT.avatarUrl });
}

function translate(lang, dict) {
  return dict[lang] || dict['en'] || Object.values(dict)[0];
}

const LEAD_INTENT_KEYWORDS = [
  "precio",
  "valor",
  "cu√°nto cuesta",
  "cuanto cuesta",
  "interesado",
  "ficha",
  "quiero visitar",
  "agenda visita",
  "contactar",
  "est√° disponible",
  "esta disponible",
  "me interesa ese departamento",
  "piso disponible",
  "mandame info",
  "env√≠ame info",
  "enviame info"
];

function detectLeadIntentFromKeywords(text = "") {
  const normalized = text.toLowerCase();
  return LEAD_INTENT_KEYWORDS.some((keyword) => normalized.includes(keyword));
}

function detectPreferredMethod(text = "") {
  const normalized = text.toLowerCase();
  if (normalized.includes("whatsapp") || normalized.includes("wasap") || normalized.includes("wasapp")) {
    return "whatsapp";
  }
  if (normalized.includes("email") || normalized.includes("correo")) {
    return "email";
  }
  return "whatsapp";
}

function hideLeadCapturePopup() {
  if (leadCapturePopupEl?.parentNode) {
    leadCapturePopupEl.parentNode.removeChild(leadCapturePopupEl);
  }
  leadCapturePopupEl = null;
  leadCaptureState = null;
}

function showLeadCapturePopup({ reason = "", suggestedMethod } = {}) {
  if (!leadCaptureEnabled || leadCaptureCompleted) return;
  if (leadCapturePopupEl) return;

  const initialMethod = suggestedMethod === "email" ? "email" : "whatsapp";
  leadCaptureState = { reason, method: initialMethod };
  leadPromptShown = true;

  const { wrap, msg } = createAssistantBubble(CURRENT.avatarUrl);
  wrap.dataset.leadPopup = "1";
  wrap.style.animation = "slideInLead 0.35s cubic-bezier(.21,.75,.27,1.02)";
  msg.classList.add(
    "backdrop-blur-md",
    "bg-white/70",
    "rounded-2xl",
    "border",
    "border-white/30",
    "shadow-xl",
    "p-4"
  );
  leadCapturePopupEl = wrap;

  const titleText = translateText("Recibir informaci√≥n");
  const nameLabel = translateText("Nombre");
  const whatsappLabel = translateText("WhatsApp");
  const emailLabel = translateText("Email");
  const submitLabel = translateText("Enviar datos");

  const form = document.createElement("form");
  form.className = "w-full";

  const headerRow = document.createElement("div");
  headerRow.className = "flex items-start justify-between gap-2 mb-3";
  const titleEl = document.createElement("p");
  titleEl.className = "text-sm font-semibold text-gray-800";
  titleEl.innerHTML =
    `<div class="flex items-center gap-2"> <i data-lucide="mail-plus" class="w-4 h-4 text-gray-700"></i> <span>${titleText}</span>

   </div>`;
  headerRow.append(titleEl);

  const tabsRow = document.createElement("div");
  tabsRow.className = "flex items-center gap-2 mb-3";
  const tabBase =
    "flex-1 px-3 py-2 text-xs font-medium rounded-full bg-white/40 border border-white/30 backdrop-blur-md shadow-sm transition";
  const whatsappTab = document.createElement("button");
  whatsappTab.type = "button";
  whatsappTab.dataset.method = "whatsapp";
  whatsappTab.className = tabBase;
  whatsappTab.textContent = whatsappLabel;
  const emailTab = document.createElement("button");
  emailTab.type = "button";
  emailTab.dataset.method = "email";
  emailTab.className = tabBase;
  emailTab.textContent = emailLabel;
  tabsRow.append(whatsappTab, emailTab);

  const fieldsWrap = document.createElement("div");
  fieldsWrap.className = "space-y-2";
  const nameInput = document.createElement("input");
  nameInput.type = "text";
  nameInput.required = true;
  nameInput.placeholder = nameLabel;
  nameInput.className =
    "w-full px-3 py-2 rounded-xl bg-white/60 border border-white/40 text-sm focus:outline-none focus:bg-white/90 focus:border-gray-400";

  const contactInput = document.createElement("input");
  contactInput.required = true;
  contactInput.className =
    "w-full px-3 py-2 rounded-xl bg-white/60 border border-white/40 text-sm focus:outline-none focus:bg-white/90 focus:border-gray-400";

  let currentMethod = initialMethod;

  const nameWrap = document.createElement("div");
  nameWrap.className = "relative";
  nameWrap.innerHTML = `<i data-lucide="user" class="w-4 h-4 text-gray-400 absolute left-3 top-2.5"></i>`;
  nameWrap.appendChild(nameInput);
  nameInput.classList.add("pl-9");

  const contactWrap = document.createElement("div");
  contactWrap.className = "relative";
  contactWrap.innerHTML = `<i data-lucide="${currentMethod === 'email' ? 'mail' : 'phone'}" class="w-4 h-4 text-gray-400 absolute left-3 top-2.5"></i>`;
  contactWrap.appendChild(contactInput);
  contactInput.classList.add("pl-9");

  const errorName = document.createElement("p");
  errorName.className = "text-xs text-red-500 mt-1 hidden";
  const errorContact = document.createElement("p");
  errorContact.className = "text-xs text-red-500 mt-1 hidden";

  const submitBtn = document.createElement("button");
  submitBtn.type = "submit";
  submitBtn.className =
    "mt-3 w-full px-4 py-2 rounded-full bg-black/70 text-white text-sm font-semibold shadow-lg backdrop-blur-md hover:bg-black/90 active:scale-95 transition";
  submitBtn.textContent = submitLabel;

const applyMethodState = (method) => {
  currentMethod = method === "email" ? "email" : "whatsapp";
  leadCaptureState = { ...leadCaptureState, method: currentMethod };

  // reset
  whatsappTab.className = tabBase;
  emailTab.className = tabBase;

  // limpiar texto y restaurar labels base
  whatsappTab.innerHTML = whatsappLabel;
  emailTab.innerHTML = emailLabel;

  // quitar fondo blanco transl√∫cido que bloquea el gris
  whatsappTab.classList.remove("bg-white/40");
  emailTab.classList.remove("bg-white/40");

  if (currentMethod === "whatsapp") {
    whatsappTab.classList.add("bg-gray-200", "text-gray-800", "shadow");

    // agregar check icon
    whatsappTab.innerHTML =
      `<i data-lucide="check" class="w-4 h-4 inline-block mr-1"></i> ${whatsappLabel}`;
  } else {
    emailTab.classList.add("bg-gray-200", "text-gray-800", "shadow");

    // agregar check icon
    emailTab.innerHTML =
      `<i data-lucide="check" class="w-4 h-4 inline-block mr-1"></i> ${emailLabel}`;
  }

  contactInput.type = currentMethod === "email" ? "email" : "tel";
  contactInput.placeholder = currentMethod === "email" ? emailLabel : whatsappLabel;

  const contactIcon = contactWrap.querySelector("i[data-lucide]");
  if (contactIcon) {
    contactIcon.setAttribute("data-lucide", currentMethod === "email" ? "mail" : "phone");
  }

  // re-render icons
  lucide.createIcons();
};

  whatsappTab.addEventListener("click", () => applyMethodState("whatsapp"));
  emailTab.addEventListener("click", () => applyMethodState("email"));

  nameInput.addEventListener("input", () => {
    errorName.classList.add("hidden");
    nameInput.classList.remove("border-red-400");
  });

  contactInput.addEventListener("input", () => {
    errorContact.classList.add("hidden");
    contactInput.classList.remove("border-red-400");
  });

  form.addEventListener("submit", async (event) => {
    event.preventDefault();
    let valid = true;
    if (!nameInput.value.trim()) {
      errorName.textContent = translateText("Este campo es obligatorio");
      errorName.classList.remove("hidden");
      nameInput.classList.add("border-red-400");
      valid = false;
    }
    if (!contactInput.value.trim()) {
      errorContact.textContent = translateText("Este debe ser v√°lido");
      errorContact.classList.remove("hidden");
      contactInput.classList.add("border-red-400");
      valid = false;
    }
    if (currentMethod === "email" && !/^[^@\s]+@[^@\s]+.[^@\s]+$/.test(contactInput.value)) {
      errorContact.textContent = translateText("Correo inv√°lido");
      errorContact.classList.remove("hidden");
      contactInput.classList.add("border-red-400");
      valid = false;
    }
    if (currentMethod === "whatsapp" && contactInput.value.length < 6) {
      errorContact.textContent = translateText("N√∫mero inv√°lido");
      errorContact.classList.remove("hidden");
      contactInput.classList.add("border-red-400");
      valid = false;
    }
    if (!valid) {
      event.preventDefault();
      return;
    }
    const name = nameInput.value.trim();
    const contact = contactInput.value.trim();
    submitBtn.disabled = true;
    try {
      await saveLeadToFirebase({
        name,
        contact,
        method: currentMethod,
        reason
      });
      hideLeadCapturePopup();
      leadCaptureCompleted = true;
      renderAssistantMessage(translateText("¬°Gracias! Nuestro asesor te contactar√° pronto üòä"));
    } catch (err) {
      console.warn("No se pudo guardar el lead desde el popup", err);
    } finally {
      submitBtn.disabled = false;
    }
  });

  fieldsWrap.append(nameWrap, errorName, contactWrap, errorContact);
  form.append(headerRow, tabsRow, fieldsWrap, submitBtn);
  msg.appendChild(form);

  lucide.createIcons();

  applyMethodState(initialMethod);
  setTimeout(() => nameInput.focus(), 50);
}

function buildLeadSummaryTranscript(maxEntries = 16) {
  if (!conversationLog.length) return '';
  const relevantEntries = conversationLog.slice(-Math.max(1, maxEntries));
  return relevantEntries
    .map(entry => {
      const prefix = entry.sender === 'bot' ? 'Asistente' : 'Usuario';
      const cleaned = (entry.text || '')
        .replace(/\s+/g, ' ')
        .trim();
      return `${prefix}: ${cleaned}`.trim();
    })
    .filter(Boolean)
    .join('\n');
}

function parseLeadSummaryResponse(content) {
  if (!content) return null;
  const trimmed = content.trim();
  if (!trimmed) return null;
  const jsonBlockMatch = trimmed.match(/```json([\s\S]*?)```/i);
  const textToParse = jsonBlockMatch ? jsonBlockMatch[1].trim() : trimmed;
  const buildNoteFromObject = (obj) => {
    if (!obj || typeof obj !== 'object') return null;
    const note = {};
    ['es', 'en'].forEach((lang) => {
      const value = obj[lang];
      if (typeof value === 'string' && value.trim()) {
        note[lang] = value.trim();
      }
    });
    return Object.keys(note).length ? note : null;
  };
  try {
    const parsed = JSON.parse(textToParse);
    if (typeof parsed === 'string') {
      const clean = parsed.trim();
      return clean ? { es: clean } : null;
    }
    const fromObject = buildNoteFromObject(parsed);
    if (fromObject) return fromObject;
  } catch (err) {
    // ignore parsing errors and fall back to plain text below
  }
  const fallback = textToParse.replace(/\s+/g, ' ').trim();
  return fallback ? { es: fallback } : null;
}

async function generateLeadSummaryFromConversation() {
  const transcript = buildLeadSummaryTranscript();
  if (!transcript) return null;
  const summarySystemPrompt = `Eres un asistente que redacta notas breves sobre conversaciones de clientes.
Devuelve un JSON con los campos "es" y "en".
Cada campo debe contener una frase corta (m√°ximo 30 palabras) que resuma por qu√© se obtuvo el lead y qu√© necesita el usuario.`;
  const body = {
    messages: [
      {
        role: 'user',
        content: `Transcripci√≥n del chat:\n${transcript}\n\nResume por qu√© se guard√≥ este lead.`
      }
    ],
    system: summarySystemPrompt
  };
  try {
    const response = await fetch(PROXY_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!response.ok) {
      console.warn('No se pudo obtener el resumen del lead', response.status);
      return null;
    }
    const data = await response.json();
    const content = data?.choices?.[0]?.message?.content;
    return parseLeadSummaryResponse(content);
  } catch (err) {
    console.warn('Error al generar el resumen del lead', err);
    return null;
  }
}


/* =========================
   AUTO RESPONSES (desde Admin beta3)
========================= */
let AUTO = {}; // { id: {trigger, type, text, cards, extras} }
let FIRST_MENU = { enabled: false, buttons: [] };
function toYouTubeEmbed(url = '') {
  const match = (url || '').match(/(?:youtu\.be\/|v=)([\w-]{11})/);
  if (match && match[1]) return `https://www.youtube.com/embed/${match[1]}`;
  return url;
}
function normalizeFirstMenu(payload = {}) {
  const rawButtons = Array.isArray(payload?.buttons) ? payload.buttons : [];
  const buttons = rawButtons
    .map(btn => ({
      label: (btn?.label || "").trim(),
      message: (btn?.message || "").trim()
    }))
    .filter(btn => btn.label && btn.message)
    .slice(0, 5);
  return {
    enabled: !!payload?.enabled,
    buttons
  };
}
function getFirstMenuKey() {
  return `firstMenuOnce_${EMPRESA}_${BOT}`;
}
function renderInitialMenu() {
  if (!initialMenuContainer) return false;
  if (!FIRST_MENU.enabled || !FIRST_MENU.buttons || !FIRST_MENU.buttons.length) {
    initialMenuContainer.innerHTML = "";
    initialMenuContainer.classList.add('hidden');
    return false;
  }
  initialMenuContainer.innerHTML = buildFirstMenuHtml();
  initialMenuContainer.classList.remove('hidden');
  return true;
}
function buildFirstMenuHtml() {
  const buttons = FIRST_MENU.buttons || [];
  const btns = buttons.map(btn => {
    const label = escapeHtml(btn.label || "");
    const payload = encodeURIComponent(btn.message || "");
    return `<button class="pill-btn first-menu-option" data-message="${payload}">${label}</button>`;
  }).join("");
  return btns;
}
function showFirstMenu({ force = false } = {}) {
  if (renderInitialMenu()) return;
  if (!FIRST_MENU.enabled) return;
  if (!FIRST_MENU.buttons || !FIRST_MENU.buttons.length) return;
  const key = getFirstMenuKey();
  if (!force && sessionStorage.getItem(key)) return;
  const html = `<div class="flex flex-wrap justify-center gap-2">${buildFirstMenuHtml()}</div>`;
  addAssistantMessageHTML(html, {
    avatarUrl: CURRENT.avatarUrl,
    rawText: FIRST_MENU.buttons.map(btn => btn.label).join(", ")
  });
  if (!force) sessionStorage.setItem(key, '1');
}
function requestInitialMenu() {
  showFirstMenu();
}
function tryAutoResponse(userText){
  if (!userText || !AUTO) return false;
  const t = userText.toLowerCase();
  // Encuentra la primera coincidencia simple por "includes"
  const hit = Object.values(AUTO).find(r => (r.trigger||"").toLowerCase().trim() && t.includes(r.trigger.toLowerCase().trim()));
  if (!hit) return false;

  const delayOpts = { avatarUrl: CURRENT.avatarUrl };
  const delayMs = 2000;

  if (hit.type === 'text') {
    const parts = [];
    if (hit.extras?.image) parts.push(`<img src="${hit.extras.image}" class="w-full max-w-xs rounded-lg mb-2">`);
    if (hit.extras?.title) parts.push(`<div class="font-semibold">${hit.extras.title}</div>`);
    if (hit.extras?.subtitle) parts.push(`<div class="text-sm text-gray-600">${hit.extras.subtitle}</div>`);
    if (hit.text) parts.push(`<div class="mt-1">${linkify(marked.parseInline(hit.text))}</div>`);
    if (Array.isArray(hit.extras?.buttons) && hit.extras.buttons.length){
      parts.push(`<div class="mt-2 flex flex-wrap gap-2">` +
        hit.extras.buttons.filter(b=>b?.label).map(b=>{
          const href = b.link || "#";
          return `<a href="${href}" target="_blank" class="pill-btn">${b.label}</a>`;
        }).join("") + `</div>`);
    }
    const html = parts.join("");
    delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
    return true;
  }

  if (hit.type === 'cards') {
    const cards = (hit.cards||[]).map(c=>`
      <div class="card">
        ${c.image ? `<img src="${c.image}" alt="">` : ``}
        <div class="in">
          ${c.title? `<div class="title">${c.title}</div>`:``}
          ${c.subtitle? `<div class="sub">${c.subtitle}</div>`:``}
          ${c.link ? `<a href="${c.link}" target="_blank" class="pill-btn">${c.buttonText||'Ver'}</a>` : ``}
        </div>
      </div>
    `).join("");
    const html = `<div class="cards">${cards}</div>`;
    delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
    return true;
  }

  if (hit.type === 'menu') {
    const label = hit.text ? `<div class="mb-2">${hit.text}</div>` : '';
    const btns = (hit.extras?.buttons||[]).map(b=>{
      if (!b?.label) return '';
      const action = b.trigger || b.link || '';
      if (/^https?:\/\//i.test(action)) {
        return `<a href="${action}" target="_blank" class="pill-btn">${b.label}</a>`;
      }
      // bot√≥n que simula un "trigger" (env√≠a el texto)
      return `<button class="pill-btn chat-option" data-trigger="${action}">${b.label}</button>`;
    }).join("");
    const html = `${label}<div class="flex flex-wrap gap-2">${btns}</div>`;
    delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
    return true;
  }

  if (hit.type === 'video') {
    const youtubeUrl = typeof hit.youtubeUrl === 'string' ? hit.youtubeUrl.trim() : '';
    if (youtubeUrl) {
      const embedUrl = toYouTubeEmbed(youtubeUrl);
      const html = `
<div class="w-full">
  <iframe
    width="100%"
    height="215"
    src="${embedUrl}"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen
  ></iframe>
</div>
      `;
      delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
      return true;
    }

    const videoUrl = typeof hit?.extras?.videoUrl === 'string' ? hit.extras.videoUrl.trim() : '';
    if (!videoUrl) return false;
    const embedUrl = toYouTubeEmbed(videoUrl);
    const caption = hit.extras?.videoCaption ? `<p class="mt-2 text-sm text-gray-700">${hit.extras.videoCaption}</p>` : '';
    const html = `
<div class="w-full max-w-xl" style="min-width:300px;">
  <div class="rounded-xl overflow-hidden border border-gray-200 shadow-sm">
    <div class="relative" style="padding-top:56.25%;">
      <iframe src="${embedUrl}" class="absolute inset-0 w-full h-full" allowfullscreen></iframe>
    </div>
  </div>
  ${caption}
</div>
    `;
    delayedAssistantAction(() => addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl }), delayMs, delayOpts);
    return true;
  }

  return false;
}

/* Delegaci√≥n para botones de men√∫ (menu->trigger) */
document.addEventListener('click', (e)=>{
  const b = e.target.closest('.chat-option');
  if (!b) return;
  const trig = (b.dataset.trigger||'').trim();
  if (!trig) return;
  // Muestra como si el usuario hubiera escrito
  addUserMessage(trig);
  handleUserMessage(trig);
});
document.addEventListener('click', (e) => {
  const option = e.target.closest('.first-menu-option');
  if (option) {
    const payload = option.dataset.message || "";
    const message = decodeURIComponent(payload);
    if (!message) return;
    addUserMessage(message);
    handleUserMessage(message);
    return;
  }
});

/* =========================
   WELCOME (desde config/chatWelcome)
========================= */
function scheduleWelcome(){
  const key = `welcomeOnce_${EMPRESA}_${BOT}`;
  if (sessionStorage.getItem(key)) return;
  const ref = eref('config/chatWelcome');
  ref.once('value').then(s=>{
    const val = s.val() || {};
    if (!val.enabled) {
      requestInitialMenu();
      return;
    }
    const delay = Math.max(0, parseInt(val.delay||2));
    setTimeout(()=>{
      const parts=[];
      if (val.image) parts.push(`<img src="${val.image}" class="w-full max-w-xs rounded-lg mb-2" />`);
      if (val.text) parts.push(marked.parse(val.text));
      const html = parts.join("");
      delayedAssistantAction(() => {
        addAssistantMessageHTML(html, { avatarUrl: CURRENT.avatarUrl });
        requestInitialMenu();
        sessionStorage.setItem(key, '1');
      });
    }, delay*1000);
  });
}

/* =========================
   IA: MENSAJER√çA
========================= */
const MESSAGES = []; // {role:'system'|'user'|'assistant', content:string}
const CURRENT = { avatarUrl: "", hotelName: "", contextInfo: "", personality:"warm" };


async function askAI(userText) {
  const combinedSystem = `
  ${SYSTEM_PROMPT || ""}

  Use the following hotel information to answer the guest accurately:

  ${CURRENT.contextInfo || ""}
  `;

  const body = {
    messages: MESSAGES,
    system: combinedSystem
  };

  const res = await fetch(PROXY_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!res.ok) throw new Error("IA request failed: " + res.status);
  const data = await res.json();
  return data?.choices?.[0]?.message?.content || "";
}

async function handleUserMessage(text){
  const safeText = typeof text === 'string' ? text : '';
  userMessageCount += 1;

  const shouldShowLeadPopup =
    leadCaptureEnabled &&
    !leadCaptureCompleted &&
    !leadPromptShown &&
    !leadCapturePopupEl &&
    userMessageCount > 1 &&
    detectLeadIntentFromKeywords(safeText);

  if (shouldShowLeadPopup) {
    const suggestedMethod = detectPreferredMethod(safeText);
    showLeadCapturePopup({ reason: "detectedInterest", suggestedMethod });
    return;
  }

  MESSAGES.push({ role:'user', content:safeText });

  // 1) AutoResponses (si hay match, responde y no llama IA)
  if (tryAutoResponse(safeText)) return;

  // 2) IA
  const typing = showTypingIndicator();

  try{
    const reply = await askAI(safeText);
    MESSAGES.push({ role:'assistant', content: reply });
    removeTyping(typing);
    addAssistantMessage(reply, { avatarUrl: CURRENT.avatarUrl });
  }catch(err){
    console.error(err);
    removeTyping(typing);
    addAssistantMessage("Lo siento, hubo un problema al responder. ¬øPuedes intentar nuevamente?");
  }
}

/* =========================
   SEND (bot√≥n y Enter)
========================= */
async function sendNow(){
  const t = (input.value || "").trim();
  if (!t) return;
  addUserMessage(t);
  input.value = "";
  handleUserMessage(t);
}
sendBtn.addEventListener('click', sendNow);
input.addEventListener('keydown', e=>{ if(e.key === 'Enter'){ e.preventDefault(); sendNow(); }});

function setChatMenuVisibility(show) {
  if (!chatMenu) return;
  const shouldShow = Boolean(show);
  if (shouldShow) {
    chatMenu.classList.remove('hidden');
    chatMenuBtn?.setAttribute('aria-expanded', 'true');
  } else {
    chatMenu.classList.add('hidden');
    chatMenuBtn?.setAttribute('aria-expanded', 'false');
  }
}

function toggleChatMenu() {
  if (!chatMenu) return;
  const isHidden = chatMenu.classList.contains('hidden');
  setChatMenuVisibility(isHidden);
}

function formatConversationTimestamp(time) {
  const date = new Date(time);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  let hours = date.getHours();
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  const suffix = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12 || 12;
  const hh = String(hours).padStart(2, '0');
  return `${year}-${month}-${day} ${hh}:${minutes}:${seconds} ${suffix}`;
}

function buildConversationExport() {
  const lines = [];
  const hotelName = (CURRENT.hotelName || hotelNameEl?.textContent || 'Hotel assistant').trim();
  const startTime = conversationLog[0]?.time || Date.now();
  const visitorName = (typeof getChatUserName === 'function' ? getChatUserName() : 'Visitor') || 'Visitor';
  lines.push(`Conversation with ${hotelName}`);
  lines.push(`Started on ${new Date(startTime).toUTCString()}`);
  lines.push('');

  conversationLog.forEach(entry => {
    const timestamp = formatConversationTimestamp(entry.time);
    const senderLabel = entry.sender === 'bot' ? 'Chatbot' : visitorName;
    const message = (entry.text || '').replace(/\r?\n/g, '\n    ');
    lines.push(`${timestamp} | ${senderLabel}: ${message}`);
  });

  return lines.join('\n');
}

function downloadConversation() {
  const content = buildConversationExport();
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  const isoDate = new Date().toISOString().slice(0, 10);
  link.download = `conversation-${isoDate}.txt`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

if (chatMenuBtn) {
  chatMenuBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    toggleChatMenu();
  });
}

if (downloadChatBtn) {
  downloadChatBtn.addEventListener('click', () => {
    try {
      downloadConversation();
    } finally {
      setChatMenuVisibility(false);
    }
  });
}

document.addEventListener('click', (event) => {
  if (!chatMenu || chatMenu.classList.contains('hidden')) return;
  if (chatMenu.contains(event.target)) return;
  if (chatMenuBtn && chatMenuBtn.contains(event.target)) return;
  setChatMenuVisibility(false);
});

document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    setChatMenuVisibility(false);
  }
});

/* =========================
   CARGA DESDE FIREBASE (colores, logo, avatar, nombre, contexto, personality, autoResponses)
========================= */
function applyPrimaryColor(color){
  document.documentElement.style.setProperty('--chat-primary', color || '#111111');
}
function initFirebaseBindings() {
  // Colores
  eref('config/chatPrimaryColor').on('value', s => applyPrimaryColor(s.val() || '#111111'));

  // üÜï Fondo del chat
  eref('config/chatBackgroundColor').on('value', s => {
    const bg = s.val() || '#ececec';
    const chatWin = document.getElementById('chatWindow');
    if (chatWin) chatWin.style.background = bg;

    // Opcional: tambi√©n el body si el chat ocupa toda la pantalla
    document.body.style.background = bg;
  });
  
// üü£ Header Background Color
eref('config/chatHeaderColor').on('value', s => {
  const h = s.val() || '#ffffff';
  const chatHeader = document.getElementById('chatHeader');
  if (chatHeader) chatHeader.style.background = h;
});

// üÜï Header visibility toggle
const applyChatHeaderVisibility = (value) => {
  const chatHeaderEl = document.getElementById('chatHeader');
  if (!chatHeaderEl) return;
  const isVisible = value === false ? false : true;
  chatHeaderEl.style.display = isVisible ? '' : 'none';
};

eref('config/chatHeaderVisible').on('value', (s) => {
  applyChatHeaderVisibility(s.val());
});

// üü¶ Header Text Color
eref('config/chatHeaderTextColor').on('value', s => {
  const c = s.val() || '#1f2937';
  document.documentElement.style.setProperty('--chat-header-text', c);
});

// üü¢ Assistant Text Color
eref('config/chatAssistantTextColor').on('value', s => {
  const c = s.val() || '#000000';
  const msgs = document.querySelectorAll('.chat-assistant .msg');
  msgs.forEach(m => m.style.color = c);
  // Guarda el color actual para los nuevos mensajes
  document.documentElement.style.setProperty('--assistant-text', c);
});


// üü† Client Text Color
eref('config/chatClientTextColor').on('value', s => {
  const c = s.val() || '#ffffff';
  document.documentElement.style.setProperty('--chat-client-text', c);
  document.querySelectorAll('.chat-user').forEach(m => { m.style.color = c; });
});


// üü° Avatar en tiempo real
eref('config/avatarUrl').on('value', s => {
  const url = s.val() || '';
  CURRENT.avatarUrl = url;
  // Actualiza avatares visibles
  document.querySelectorAll('.avatar-icon').forEach(img => {
    if (url) img.src = url;
  });
});


  // Header hotel name
  eref('config/hotelName').on('value', s => {
    CURRENT.hotelName = s.val() || '';
    if (CURRENT.hotelName) hotelNameEl.textContent = CURRENT.hotelName;
  });

  // Logo + radio
  const logoRef = eref('config/logoUrl');
  const radiusRef = eref('config/logoRadius');
  let logoUrl = "";
  let logoRadius = 50;
  const applyLogo = () => {
    if (logoUrl) {
      chatLogo.src = logoUrl;
      chatLogo.style.borderRadius = `${logoRadius}%`;
      chatLogo.classList.remove('hidden');
    } else {
      chatLogo.classList.add('hidden');
      chatLogo.removeAttribute('src');
    }
  };
  logoRef.on('value', s => { logoUrl = s.val() || ""; applyLogo(); });
  radiusRef.on('value', s => { logoRadius = s.val() || 0; applyLogo(); });

  // Avatar
  eref('config/avatarUrl').on('value', s => {
    CURRENT.avatarUrl = s.val() || "";
  });

  const applyAvatarRadius = (value) => {
    const numeric = typeof value === 'number' ? value : parseInt(value, 10);
    const radius = Number.isFinite(numeric) ? Math.min(50, Math.max(0, numeric)) : 50;
    document.documentElement.style.setProperty('--avatar-radius', `${radius}%`);
  };

  applyAvatarRadius(50);
  eref('config/avatarRadius').on('value', s => {
    applyAvatarRadius(s.val());
  });

  // üÜï Tipograf√≠a din√°mica completa
  eref('config/fontFamily').on('value', s => {
    const f = s.val() || 'Manrope';

    // Lista de fuentes soportadas en Google Fonts
    const available = [
      "Manrope", "Inter", "Poppins", "Roboto", "Playfair Display", "Merriweather"
    ];

    // Solo intentar cargar si est√° en la lista
    if (available.includes(f)) {
      const id = `font_${f.replace(/\s+/g, '')}`;
      if (!document.getElementById(id)) {
        const link = document.createElement('link');
        link.id = id;
        link.rel = 'stylesheet';
        link.href = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(f)}:wght@400;500;600;700&display=swap`;
        document.head.appendChild(link);
      }
    }

    // Aplica siempre el font-family (aunque no se haya cargado)
    document.body.style.fontFamily = `'${f}', system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
  });

  // üß† Context info + personality (con actualizaci√≥n del system prompt)
  eref('config/contextInfo').on('value', s => {
    CURRENT.contextInfo = s.val() || "";

    // üß© Si ya existe el mensaje del sistema, actual√≠zalo
    if (MESSAGES.length > 0 && MESSAGES[0].role === 'system') {
      MESSAGES[0].content = buildSystemPrompt();
    }
  });

  eref('config/personality').on('value', s => {
    CURRENT.personality = s.val() || "warm";

    // üß© Actualizar tambi√©n el prompt si cambia la personalidad
    if (MESSAGES.length > 0 && MESSAGES[0].role === 'system') {
      MESSAGES[0].content = buildSystemPrompt();
    }
  });

  // AutoResponses
  eref('config/autoResponses').on('value', s => { AUTO = s.val() || {}; });

  // First menu
  eref('config/firstMenu').on('value', s => {
    FIRST_MENU = normalizeFirstMenu(s.val());
    renderInitialMenu();
  });

  // Welcome
  scheduleWelcome();
}


/* =========================
   INTEGRACI√ìN CON embed.js (versi√≥n estable y limpia)
========================= */
const DEFAULT_WIDGET_ICON_PATH = 'wids/1.svg';
const DEFAULT_WIDGET_ICON_COLOR = '#ffffff';
const widgetIconSvgCache = new Map();
const widgetIconSerializer = new XMLSerializer();

const normalizeHexColor = (value = '') => {
  const raw = (value || '').toString().trim();
  if (/^#?[0-9a-fA-F]{6}$/.test(raw)) {
    return raw.startsWith('#') ? raw.toLowerCase() : `#${raw.toLowerCase()}`;
  }
  if (/^#?[0-9a-fA-F]{3}$/.test(raw)) {
    const clean = raw.replace('#', '').toLowerCase();
    const expanded = clean.split('').map((c) => c + c).join('');
    return `#${expanded}`;
  }
  return null;
};

const resolveWidgetIconUrl = (iconPath) => {
  const normalized = (iconPath || '').trim() || DEFAULT_WIDGET_ICON_PATH;
  if (normalized.startsWith('http')) return normalized;
  const cleanPath = normalized.startsWith('/') ? normalized.slice(1) : normalized;
return `https://tomos.bot/${cleanPath}`;
};

const fetchWidgetIconMarkup = async (iconPath) => {
  const url = resolveWidgetIconUrl(iconPath);
  if (widgetIconSvgCache.has(url)) return widgetIconSvgCache.get(url);
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error('Icon fetch failed');
    const text = await res.text();
    widgetIconSvgCache.set(url, text || '');
    return text || '';
  } catch (error) {
    console.warn('No se pudo cargar el SVG del widget', error);
    return '';
  }
};

const colorizeWidgetSvg = (markup, color, size = 28) => {
  if (!markup) return null;
  const parser = new DOMParser();
  const doc = parser.parseFromString(markup, 'image/svg+xml');
  const svg = doc.querySelector('svg');
  if (!svg) return null;

  const finalColor = normalizeHexColor(color) || DEFAULT_WIDGET_ICON_COLOR;
  svg.setAttribute('fill', finalColor);
  svg.setAttribute('width', size);
  svg.setAttribute('height', size);

  svg.querySelectorAll('*').forEach((node) => {
    const tag = (node.tagName || '').toLowerCase();
    if (tag === 'svg') return;
    const fillAttr = node.getAttribute('fill');
    if (!fillAttr || fillAttr === 'currentColor') {
      node.setAttribute('fill', finalColor);
    }
    const strokeAttr = node.getAttribute('stroke');
    if (strokeAttr && strokeAttr !== 'none') {
      node.setAttribute('stroke', finalColor);
    }
  });

  return svg;
};

const getColoredWidgetSvgString = async (iconPath, color) => {
  const markup = await fetchWidgetIconMarkup(iconPath);
  const svg = colorizeWidgetSvg(markup, color);
  if (!svg) return null;
  return widgetIconSerializer.serializeToString(svg);
};

function initEmbedIntegration() {
  // üîπ estado local de visibilidad del bot√≥n (por defecto TRUE)
  let CHAT_BUTTON_VISIBLE = true;

  // üîπ Suscribirse a config/chatVisible en Firebase
  if (typeof eref === "function") {
    eref("config/chatVisible").on("value", (snap) => {
      const raw = snap.val();
      // si es false => oculto, si no existe o es true => visible
      CHAT_BUTTON_VISIBLE = raw === false ? false : true;

      // Enviar actualizaci√≥n inmediata al embed (por si ya est√° listo)
      try {
        window.parent.postMessage(
          { action: "chatButtonStatus", visible: CHAT_BUTTON_VISIBLE },
          "*"
        );
      } catch (e) {}
    });
  }

  window.addEventListener("message", (e) => {
    if (!e.data || typeof e.data !== "object") return;
    const { action } = e.data;

    if (action === "externalOrigin") {
      if (externalOriginFallbackTimeout) {
        clearTimeout(externalOriginFallbackTimeout);
        externalOriginFallbackTimeout = null;
      }
      saveExternalOriginToFirebase(e.data?.externalOrigin);
      return;
    }

    if (action === "getChatButtonIcon") {
      if (typeof eref !== "function") {
        console.warn("eref no disponible a√∫n");
        return;
      }

      Promise.all([
        eref("config/widgetIcon").once("value"),
        eref("config/widgetRadius").once("value"),
        eref("config/widgetIconColor").once("value")
      ]).then(async ([iconSnap, radiusSnap, colorSnap]) => {
        const iconPath = iconSnap.val() || DEFAULT_WIDGET_ICON_PATH;
        const radius = radiusSnap.val() || 0;
        const iconColor = normalizeHexColor(colorSnap.val()) || DEFAULT_WIDGET_ICON_COLOR;

        let svg = await getColoredWidgetSvgString(iconPath, iconColor);

        if (!svg) {
          svg = `
            <svg xmlns="http://www.w3.org/2000/svg" fill="${iconColor}" viewBox="0 0 24 24">
              <path d="M7 8h10M7 12h6m-6 4h8m-5 8c-1.654 0-3-.346-3-1v-1.691c-3.771-1.466-6-4.718-6-8.309C1 5.373 5.373 1 11 1s10 4.373 10 9c0 3.591-2.229 6.843-6 8.309V21c0 .654-1.346 1-3 1z" />
            </svg>`;
        }

        window.parent.postMessage(
          { action: "chatButtonIcon", svg, radius },
          "*"
        );
      });
    }

    if (action === "getChatButtonStatus") {
      // üîπ responder usando el valor real de Firebase
      window.parent.postMessage(
        { action: "chatButtonStatus", visible: CHAT_BUTTON_VISIBLE },
        "*"
      );
    }

    if (action === "openChatWindow") {
      const w = document.getElementById("chatWindow");
      if (w) w.style.display = "flex";
    }
  });

  // Avisar que el chat est√° listo
  window.parent.postMessage({ action: "chatReady" }, "*");

  // üîπ Color del bot√≥n
  if (typeof eref === "function") {
    eref("config/chatButtonColor").on("value", (s) => {
      const color = s.val() || "#111111";
      window.parent.postMessage(
        { action: "updateChatButtonColor", color },
        "*"
      );
    });

    const sendWidgetPosition = (pos) => {
      const valid = ["left", "center", "right"];
      const normalizedInput = (pos || "").toString().trim().toLowerCase();
      const normalized = valid.includes(normalizedInput)
        ? normalizedInput
        : "right";

      window.parent.postMessage(
        { action: "updateWidgetPosition", position: normalized },
        "*"
      );
    };

    eref("config/widgetPosition").on("value", (s) => {
      sendWidgetPosition(s.val());
    });
  }
}

/* =========================
   INICIO GLOBAL (espera Firebase y luego integra embed.js)
========================= */
document.addEventListener("DOMContentLoaded", async () => {
  lucide.createIcons();
  await prepareBotPath();
  initSystemPromptListener();
  initFirebaseBindings();

  // Cerrar chat
  document.getElementById("closeChat").addEventListener("click", () => {
    try {
      if (window.parent !== window)
        window.parent.postMessage({ action: "closeChatWindow" }, "*");
    } catch (e) {}
  });

  // Iniciar integraci√≥n con embed.js despu√©s que Firebase est√© listo
  const tryInit = () => {
    if (typeof firebase !== "undefined" && typeof eref === "function") {
      initEmbedIntegration();
    } else {
      console.warn("‚è≥ Esperando Firebase para integraci√≥n...");
      setTimeout(tryInit, 600);
    }
  };
  tryInit();
});

async function saveLeadToFirebase({ name, contact, method = "whatsapp", reason = "" } = {}) {
  const safeName = (name || "").trim();
  const safeContact = (contact || "").trim();
  if (!safeName || !safeContact) return;

  const normalizedMethod = method === "email" ? "email" : "whatsapp";
  const now = Date.now();
  const lead = {
    name: safeName,
    contact: safeContact,
    lang: USER_LANGUAGE,
    method: normalizedMethod,
    timestamp: now,
    capturedAt: new Date(now).toISOString(),
    time: now
  };

  if (normalizedMethod === "email") {
    lead.email = safeContact;
  } else {
    lead.phone = safeContact;
  }

  if (reason) {
    lead.reason = reason;
  }

  try {
    const note = await generateLeadSummaryFromConversation();
    if (note) {
      lead.note = note;
      lead.summary = note;
    }
  } catch (err) {
    console.warn('No se pudo crear el resumen del lead', err);
  }

  try {
    const ref = db.ref(`empresas/${EMPRESA}/bots/${BOT}/leads`).push();
    await ref.set(lead);
  } catch (err) {
    console.warn('No se pudo guardar el lead', err);
    throw err;
  } finally {
    leadCaptureState = null;
  }
}


  </script>

</body>
</html>
